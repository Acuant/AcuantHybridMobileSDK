"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const command_1 = require("@ionic/cli-utils/lib/command");
const errors_1 = require("@ionic/cli-utils/lib/errors");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const base_1 = require("./base");
const AVAILABLE_RESOURCE_TYPES = ['icon', 'splash'];
let ResourcesCommand = class ResourcesCommand extends base_1.CordovaCommand {
    preRun(inputs, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.preRunChecks();
            const { promptToLogin } = yield Promise.resolve().then(function () { return require('@ionic/cli-utils/lib/session'); });
            const isLoggedIn = yield this.env.session.isLoggedIn();
            if (!isLoggedIn) {
                this.env.log.warn(`You need to be logged into your Ionic account in order to run ${chalk_1.default.green(`ionic cordova resources`)}.\n`);
                yield promptToLogin(this.env);
            }
        });
    }
    run(inputs, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { ConfigXml } = yield Promise.resolve().then(function () { return require('@ionic/cli-utils/lib/cordova/config'); });
            const { getPlatforms, installPlatform } = yield Promise.resolve().then(function () { return require('@ionic/cli-utils/lib/cordova/project'); });
            const { prettyPath } = yield Promise.resolve().then(function () { return require('@ionic/cli-utils/lib/utils/format'); });
            const { RESOURCES, addResourcesToConfigXml, createImgDestinationDirectories, findMostSpecificImage, getImageResources, getSourceImages, transformResourceImage, uploadSourceImages, } = yield Promise.resolve().then(function () { return require('@ionic/cli-utils/lib/cordova/resources'); });
            const [platform] = inputs;
            const { force } = options;
            let conf = yield ConfigXml.load(this.env.project.directory);
            // if no resource filters are passed as arguments assume to use all.
            let resourceTypes = AVAILABLE_RESOURCE_TYPES.filter((type, index, array) => options[type]);
            resourceTypes = resourceTypes.length ? resourceTypes : AVAILABLE_RESOURCE_TYPES;
            this.env.tasks.next(`Collecting resource configuration and source images`);
            this.env.log.debug(() => `resourceJsonStructure=${Object.keys(RESOURCES).length}`);
            // check that at least one platform has been installed
            let platforms = yield getPlatforms(this.env.project.directory);
            this.env.log.debug(() => `platforms=${platforms.map(e => chalk_1.default.bold(e)).join(', ')}`);
            if (platform && !platforms.includes(platform)) {
                this.env.tasks.end();
                const confirm = yield this.env.prompt({
                    message: `Platform ${chalk_1.default.green(platform)} not detected. Would you like to install it?`,
                    type: 'confirm',
                    name: 'confirm',
                });
                if (confirm) {
                    yield installPlatform(this.env, platform);
                    conf = yield ConfigXml.load(this.env.project.directory);
                    platforms = yield getPlatforms(this.env.project.directory);
                    this.env.log.debug(() => `platforms=${platforms.map(e => chalk_1.default.bold(e)).join(', ')}`);
                }
                else {
                    throw new errors_1.FatalException(`Platform ${chalk_1.default.green(platform)} not installed.`);
                }
            }
            const buildPlatforms = Object.keys(RESOURCES).filter(p => platforms.includes(p));
            this.env.log.debug(() => `buildPlatforms=${buildPlatforms.map(v => chalk_1.default.bold(v)).join(', ')}`);
            if (buildPlatforms.length === 0) {
                this.env.tasks.end();
                throw new errors_1.FatalException(`No platforms detected. Please run: ${chalk_1.default.green('ionic cordova platform add')}`);
            }
            this.env.log.debug(() => `${chalk_1.default.green('getProjectPlatforms')} completed: ${buildPlatforms.map(v => chalk_1.default.bold(v)).join(', ')}`);
            const orientation = conf.getPreference('Orientation') || 'default';
            // Convert the resource structure to a flat array then filter the array so
            // that it only has img resources that we need. Finally add src path to the
            // items that remain.
            let imgResources = (yield getImageResources(this.env))
                .filter(img => orientation === 'default' || typeof img.orientation === 'undefined' || img.orientation === orientation)
                .filter(img => buildPlatforms.includes(img.platform))
                .filter(img => resourceTypes.includes(img.resType));
            if (platform) {
                imgResources = imgResources.filter(img => img.platform === platform);
            }
            this.env.log.debug(() => `imgResources=${imgResources.length}`);
            // Create the resource directories that are needed for the images we will create
            const buildDirResponses = yield createImgDestinationDirectories(imgResources);
            this.env.log.debug(() => `${chalk_1.default.green('createImgDestinationDirectories')} completed: ${buildDirResponses.length}`);
            // Check /resources and /resources/<platform> directories for src files
            // Update imgResources to have their src attributes to equal the most
            // specific src img found
            let srcImagesAvailable = [];
            try {
                srcImagesAvailable = yield getSourceImages(this.env, buildPlatforms, resourceTypes);
                this.env.log.debug(() => `${chalk_1.default.green('getSourceImages')} completed: (${srcImagesAvailable.map(v => chalk_1.default.bold(prettyPath(v.path))).join(', ')})`);
            }
            catch (e) {
                this.env.log.error(`Error in ${chalk_1.default.green('getSourceImages')}: ${e.stack ? e.stack : e}`);
            }
            imgResources = imgResources.map(img => {
                const mostSpecificImageAvailable = findMostSpecificImage(img, srcImagesAvailable);
                return Object.assign({}, img, { imageId: mostSpecificImageAvailable && mostSpecificImageAvailable.imageId ? mostSpecificImageAvailable.imageId : undefined });
            });
            // If there are any imgResources that have missing images then end
            // processing and inform the user
            const missingSrcImages = imgResources.filter(img => img.imageId === null);
            if (missingSrcImages.length > 0) {
                const missingImageText = missingSrcImages
                    .reduce((list, img) => {
                    const str = `${img.platform}/${img.resType}`;
                    if (!list.includes(str)) {
                        list.push(str);
                    }
                    return list;
                }, [])
                    .map(v => chalk_1.default.bold(v))
                    .join(', ');
                throw new errors_1.FatalException(`Source image files were not found for the following platforms/types: ${missingImageText}\n` +
                    `Please review ${chalk_1.default.green('--help')}`);
            }
            this.env.tasks.next(`Filtering out image resources that do not need regeneration`);
            const cachedSourceIds = srcImagesAvailable
                .filter(img => img.imageId && img.cachedId && img.imageId === img.cachedId)
                .map(img => img.imageId);
            if (!force) {
                const keepImgResources = yield Promise.all(imgResources.map((img) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (!(yield fs_1.pathExists(img.dest))) {
                        return true;
                    }
                    return img.imageId && !cachedSourceIds.includes(img.imageId);
                })));
                imgResources = imgResources.filter((img, i) => keepImgResources[i]);
                if (imgResources.length === 0) {
                    this.env.tasks.end();
                    this.env.log.ok('No need to regenerate images--source files unchanged.');
                    return;
                }
            }
            this.env.tasks.next(`Uploading source images to prepare for transformations`);
            // Upload images to service to prepare for resource transformations
            const imageUploadResponses = yield uploadSourceImages(this.env, srcImagesAvailable);
            this.env.log.debug(() => `${chalk_1.default.green('uploadSourceImages')} completed: responses=${JSON.stringify(imageUploadResponses, null, 2)}`);
            srcImagesAvailable = srcImagesAvailable.map((img, index) => {
                return Object.assign({}, img, { width: imageUploadResponses[index].Width, height: imageUploadResponses[index].Height, vector: imageUploadResponses[index].Vector });
            });
            this.env.log.debug(() => `srcImagesAvailable=${JSON.stringify(srcImagesAvailable, null, 2)}`);
            // If any images are asking to be generated but are not of the correct size
            // inform the user and continue on.
            const imagesTooLargeForSource = imgResources.filter(img => {
                const resourceSourceImage = srcImagesAvailable.find(srcImage => srcImage.imageId === img.imageId);
                if (!resourceSourceImage) {
                    return true;
                }
                return !resourceSourceImage.vector && (img.width > resourceSourceImage.width || img.height > resourceSourceImage.height);
            });
            // Remove all images too large for transformations
            imgResources = imgResources.filter(img => {
                return !imagesTooLargeForSource.find(tooLargeForSourceImage => img.name === tooLargeForSourceImage.name);
            });
            if (imgResources.length === 0) {
                this.env.tasks.end();
                this.env.log.ok('No need to regenerate images--images too large for transformation.'); // TODO: improve messaging
                return;
            }
            // Call the transform service and output images to appropriate destination
            this.env.tasks.next(`Generating platform resources`);
            let count = 0;
            const transforms = imgResources.map((img, index) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield transformResourceImage(this.env, img);
                count += 1;
                this.env.tasks.updateMsg(`Generating platform resources: ${chalk_1.default.bold(`${count} / ${imgResources.length}`)} complete`);
            }));
            const generateImageResponses = yield Promise.all(transforms);
            this.env.tasks.updateMsg(`Generating platform resources: ${chalk_1.default.bold(`${imgResources.length} / ${imgResources.length}`)} complete`);
            this.env.log.debug(() => `${chalk_1.default.green('generateResourceImage')} completed: responses=${JSON.stringify(generateImageResponses, null, 2)}`);
            yield Promise.all(srcImagesAvailable.map((img) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield fs_1.cacheFileChecksum(img.path, img.imageId);
            })));
            this.env.tasks.next(`Modifying config.xml to add new image resources`);
            const imageResourcesForConfig = imgResources.reduce((rc, img) => {
                if (!rc[img.platform]) {
                    rc[img.platform] = {
                        [img.resType]: {
                            images: [],
                            nodeName: '',
                            nodeAttributes: []
                        }
                    };
                }
                if (!rc[img.platform][img.resType]) {
                    rc[img.platform][img.resType] = {
                        images: [],
                        nodeName: '',
                        nodeAttributes: []
                    };
                }
                rc[img.platform][img.resType].images.push({
                    name: img.name,
                    width: img.width,
                    height: img.height,
                    density: img.density || null
                });
                rc[img.platform][img.resType].nodeName = img.nodeName;
                rc[img.platform][img.resType].nodeAttributes = img.nodeAttributes;
                return rc;
            }, {});
            const platformList = Object.keys(imageResourcesForConfig);
            yield addResourcesToConfigXml(conf, platformList, imageResourcesForConfig);
            this.env.tasks.end();
            // All images that were not processed
            if (imagesTooLargeForSource.length > 0) {
                const imagesTooLargeForSourceMsg = imagesTooLargeForSource
                    .map(img => `    ${chalk_1.default.bold(img.name)}     ${img.platform}/${img.resType} needed ${img.width}×${img.height}px`)
                    .concat((imagesTooLargeForSource.length > 0) ? `\nThe following images were not created because their source image was too small:` : [])
                    .reverse();
                this.env.log.info(imagesTooLargeForSourceMsg.join('\n'));
            }
            yield conf.save();
        });
    }
};
ResourcesCommand = tslib_1.__decorate([
    command_1.CommandMetadata({
        name: 'resources',
        type: 'project',
        description: 'Automatically create icon and splash screen resources',
        longDescription: `
Ionic can automatically generate perfectly sized icons and splash screens from source images (${chalk_1.default.bold('.png')}, ${chalk_1.default.bold('.psd')}, or ${chalk_1.default.bold('.ai')}) for your Cordova platforms.

The source image for icons should ideally be at least ${chalk_1.default.bold('1024×1024px')} and located at ${chalk_1.default.bold('resources/icon.png')}. The source image for splash screens should ideally be at least ${chalk_1.default.bold('2732×2732px')} and located at ${chalk_1.default.bold('resources/splash.png')}. If you used ${chalk_1.default.green('ionic start')}, there should already be default Ionic resources in the ${chalk_1.default.bold('resources/')} directory, which you can overwrite.

You can also generate platform-specific icons and splash screens by placing them in the respective ${chalk_1.default.bold('resources/<platform>/')} directory. For example, to generate an icon for Android, place your image at ${chalk_1.default.bold('resources/android/icon.png')}.

By default, this command will not regenerate resources whose source image has not changed. To disable this functionality and always overwrite generated images, use ${chalk_1.default.green('--force')}.

For best results, the splash screen's artwork should roughly fit within a square (${chalk_1.default.bold('1200×1200px')}) at the center of the image. You can use ${chalk_1.default.bold('https://code.ionicframework.com/resources/splash.psd')} as a template for your splash screen.

${chalk_1.default.green('ionic cordova resources')} will automatically update your ${chalk_1.default.bold('config.xml')} to reflect the changes in the generated images, which Cordova then configures.

Cordova reference documentation:
- Icons: ${chalk_1.default.bold('https://cordova.apache.org/docs/en/latest/config_ref/images.html')}
- Splash Screens: ${chalk_1.default.bold('https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-splashscreen/')}

This command uses Ionic servers, so we require you to be logged into your free Ionic account. Use ${chalk_1.default.green('ionic login')} to login.
  `,
        exampleCommands: ['', 'ios', 'android'],
        inputs: [
            {
                name: 'platform',
                description: `The platform for which you would like to generate resources (${['android', 'ios'].map(v => chalk_1.default.green(v)).join(', ')})`,
                required: false,
            }
        ],
        options: [
            {
                name: 'force',
                description: 'Force regeneration of resources',
                type: Boolean,
                aliases: ['f'],
            },
            {
                name: 'icon',
                description: 'Generate icon resources',
                type: Boolean,
                aliases: ['i'],
            },
            {
                name: 'splash',
                description: 'Generate splash screen resources',
                type: Boolean,
                aliases: ['s'],
            },
        ]
    })
], ResourcesCommand);
exports.ResourcesCommand = ResourcesCommand;
