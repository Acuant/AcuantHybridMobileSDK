"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os = require("os");
const path = require("path");
const chalk_1 = require("chalk");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const errors_1 = require("./errors");
exports.INTEGRATIONS = [
    {
        name: 'cordova',
        archive: 'https://d2ql0qc7j8u4b2.cloudfront.net/integration-cordova.tar.gz',
    },
    {
        name: 'gulp',
    },
];
function enableIntegration(env, id) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const project = yield env.project.load();
        let projectIntegration = project.integrations[id];
        if (projectIntegration && projectIntegration.enabled !== false) {
            env.log.ok(`${chalk_1.default.green(id)} integration already enabled.`);
        }
        else {
            if (!projectIntegration) {
                projectIntegration = {};
            }
            if (projectIntegration.enabled === false) {
                projectIntegration.enabled = true;
                env.log.ok(`Enabled ${chalk_1.default.green(id)} integration!`);
            }
            else {
                const integration = exports.INTEGRATIONS.find(i => i.name === id);
                if (!integration) {
                    throw new errors_1.FatalException(`Integration ${id} not found in integrations list.`);
                }
                yield addIntegration(env, integration);
                env.log.ok(`Added ${chalk_1.default.green(id)} integration!`);
            }
            project.integrations[id] = projectIntegration;
        }
        yield env.project.save();
    });
}
exports.enableIntegration = enableIntegration;
function disableIntegration(env, id) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const project = yield env.project.load();
        let projectIntegration = project.integrations[id];
        if (!projectIntegration) {
            projectIntegration = {};
        }
        projectIntegration.enabled = false;
        project.integrations[id] = projectIntegration;
        env.log.ok(`Disabled ${chalk_1.default.green(id)} integration.`);
    });
}
exports.disableIntegration = disableIntegration;
function addIntegration(env, integration) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!integration.archive) {
            return;
        }
        const { download } = yield Promise.resolve().then(function () { return require('./http'); });
        const { createTarExtraction } = yield Promise.resolve().then(function () { return require('./utils/archive'); });
        const task = env.tasks.next(`Downloading integration ${chalk_1.default.green(integration.name)}`);
        const tmpdir = path.resolve(os.tmpdir(), `ionic-integration-${integration.name}`);
        // TODO: etag
        if (yield fs_1.pathExists(tmpdir)) {
            yield fs_1.removeDirectory(tmpdir);
        }
        yield fs_1.fsMkdirp(tmpdir);
        const ws = yield createTarExtraction({ cwd: tmpdir });
        yield download(env.config, integration.archive, ws, {
            progress: (loaded, total) => task.progress(loaded, total),
        });
        env.tasks.end();
        const contents = yield fs_1.readDir(tmpdir);
        const blacklist = [];
        env.log.debug(() => `Integration files downloaded to ${chalk_1.default.bold(tmpdir)} (files: ${contents.map(f => chalk_1.default.bold(f)).join(', ')})`);
        for (let f of contents) {
            const projectf = path.resolve(env.project.directory, f);
            try {
                let t = 'file';
                const stats = yield fs_1.fsStat(projectf);
                if (stats.isDirectory()) {
                    f = `${f}/`;
                    t = 'directory';
                }
                const confirm = yield env.prompt({
                    type: 'confirm',
                    name: 'confirm',
                    message: `The ${chalk_1.default.cyan(f)} ${t} exists in project. Overwrite?`,
                    default: false,
                });
                if (!confirm) {
                    blacklist.push(f);
                }
            }
            catch (e) {
                if (e.code !== 'ENOENT') {
                    throw e;
                }
            }
        }
        env.tasks.next(`Copying integrations files to project`);
        env.log.debug(() => `Blacklist: ${blacklist.map(f => chalk_1.default.bold(f)).join(', ')}`);
        yield fs_1.copyDirectory(tmpdir, env.project.directory, {
            filter: f => {
                if (f === tmpdir) {
                    return true;
                }
                const projectf = f.substring(tmpdir.length + 1);
                for (let item of blacklist) {
                    if (item.slice(-1) === '/' && `${projectf}/` === item) {
                        return false;
                    }
                    if (projectf.startsWith(item)) {
                        return false;
                    }
                }
                env.log.info(`${chalk_1.default.green.bold('create')} ${projectf}`);
                return true;
            },
        });
        env.tasks.end();
    });
}
