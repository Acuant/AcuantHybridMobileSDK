"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk_1 = require("chalk");
const semver = require("semver");
// import { isCordovaPackageJson } from '../../guards';
const app_1 = require("../app");
const backends_1 = require("../backends");
const git_1 = require("../git");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const npm_1 = require("@ionic/cli-framework/utils/npm");
const npm_2 = require("../utils/npm");
const utils_1 = require("../ionic-angular/utils");
const project_1 = require("../cordova/project");
const config_1 = require("../cordova/config");
class Ailment {
    constructor() {
        this.requiresAuthentication = false;
    }
}
exports.Ailment = Ailment;
class AutomaticallyTreatableAilment extends Ailment {
}
exports.AutomaticallyTreatableAilment = AutomaticallyTreatableAilment;
var Ailments;
(function (Ailments) {
    class AutomaticUpdatesOff extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'automatic-updates-off';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Automatic Ionic CLI updates are off.\n` +
                    `The Ionic CLI can check for updates in the background and prompt you to install updates automatically.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const config = yield env.config.load();
                return !config.daemon.updates;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    {
                        name: 'Turn on automatic updates',
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            const config = yield env.config.load();
                            config.daemon.updates = true;
                        }),
                    },
                ];
            });
        }
    }
    Ailments.AutomaticUpdatesOff = AutomaticUpdatesOff;
    class NpmInstalledLocally extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'npm-installed-locally';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`${chalk_1.default.bold('npm')} is installed locally.\n` +
                    `${chalk_1.default.bold('npm')} is typically installed globally and may cause some confusion about versions when other CLIs use it.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return fs_1.pathExists(path.join(env.project.directory, 'node_modules', 'npm'));
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [manager, ...managerArgs] = yield npm_2.pkgManagerArgs(env, { command: 'uninstall', pkg: 'npm' });
                return [
                    {
                        name: `Run: ${chalk_1.default.green(manager + ' ' + managerArgs.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.shell.run(manager, managerArgs, {});
                        }),
                    },
                ];
            });
        }
    }
    Ailments.NpmInstalledLocally = NpmInstalledLocally;
    class IonicCLIInstalledLocally extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-installed-locally';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`The Ionic CLI is installed locally.\n` +
                    `While the CLI can run locally, there's no longer a reason to have it installed locally and it may cause some confusion over configuration and versions.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return fs_1.pathExists(path.join(env.project.directory, 'node_modules', 'ionic'));
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [manager, ...managerArgs] = yield npm_2.pkgManagerArgs(env, { command: 'uninstall', pkg: 'ionic' });
                return [
                    {
                        name: `Run: ${chalk_1.default.green(manager + ' ' + managerArgs.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.shell.run(manager, managerArgs, {});
                        }),
                    },
                ];
            });
        }
    }
    Ailments.IonicCLIInstalledLocally = IonicCLIInstalledLocally;
    class GitNotUsed extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'git-not-used';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Git doesn't appear to be in use.\n` +
                    `We highly recommend using source control software such as git (${chalk_1.default.bold('https://git-scm.com')}) to track changes in your code throughout time.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!(yield git_1.isRepoInitialized(env))) {
                    return true;
                }
                const cmdInstalled = yield env.shell.cmdinfo('git', ['--version']);
                if (!cmdInstalled) {
                    return true;
                }
                const [revListCount, status] = yield Promise.all([
                    env.shell.run('git', ['rev-list', '--count', 'HEAD'], { showCommand: false }),
                    env.shell.run('git', ['status', '--porcelain'], { showCommand: false }),
                ]);
                const commitCount = Number(revListCount);
                const changes = Boolean(status);
                return commitCount === 1 && changes;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    { name: `Download git if you don't have it installed: ${chalk_1.default.bold('https://git-scm.com/downloads')}` },
                    { name: `Learn the basics if you're unfamiliar with git: ${chalk_1.default.bold('https://try.github.io')}` },
                    { name: `Make your first commit and start tracking code changes! ðŸ˜` },
                ];
            });
        }
    }
    Ailments.GitNotUsed = GitNotUsed;
    class GitConfigInvalid extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'git-config-invalid';
            this.requiresAuthentication = true;
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const appId = project.app_id;
                return (`App linked to ${chalk_1.default.bold(appId)} with invalid git configuration.\n` +
                    `This app is linked to an app on Ionic (${chalk_1.default.bold(appId)}), but the git configuration is not valid.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const config = yield env.config.load();
                const project = yield env.project.load();
                const appId = project.app_id;
                if (config.backend !== backends_1.BACKEND_PRO) {
                    return false;
                }
                if (!appId) {
                    return false;
                }
                if (!(yield git_1.isRepoInitialized(env))) {
                    return false;
                }
                const remote = yield git_1.getIonicRemote(env);
                if (!remote) {
                    return true;
                }
                const token = yield env.session.getUserToken();
                const appLoader = new app_1.App(token, env.client);
                const app = yield appLoader.load(appId);
                if (app.repo_url !== remote) {
                    return true;
                }
                return false;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const args = ['git', 'remote'];
                return [
                    {
                        name: `Run: ${chalk_1.default.green('ionic ' + args.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.runCommand(args);
                        }),
                    },
                ];
            });
        }
    }
    Ailments.GitConfigInvalid = GitConfigInvalid;
    class IonicAngularUpdateAvailable extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-angular-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getIonicAngularVersion(env, env.project);
                    this.latestVersion = yield npm_2.pkgLatestVersion(env, 'ionic-angular');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Update available for Ionic Framework.\n` +
                    `An update is available for ${chalk_1.default.bold('ionic-angular')} (${chalk_1.default.cyan(currentVersion)} => ${chalk_1.default.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'minor' || diff === 'patch';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [, latestVersion] = yield this.getVersionPair(env);
                const args = yield npm_2.pkgManagerArgs(env, { pkg: `ionic-angular@${latestVersion ? latestVersion : 'latest'}` });
                return [
                    { name: `Visit ${chalk_1.default.bold('https://github.com/ionic-team/ionic/releases')} for each upgrade's instructions` },
                    { name: `If no instructions, run: ${chalk_1.default.green(args.join(' '))}` },
                    { name: `Watch for npm warnings about peer dependencies--they may need manual updating` },
                ];
            });
        }
    }
    Ailments.IonicAngularUpdateAvailable = IonicAngularUpdateAvailable;
    class IonicAngularMajorUpdateAvailable extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-angular-major-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getIonicAngularVersion(env, env.project);
                    this.latestVersion = yield npm_2.pkgLatestVersion(env, 'ionic-angular');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Major update available for Ionic Framework.\n` +
                    `A major update is available for ${chalk_1.default.bold('ionic-angular')} (${chalk_1.default.cyan(currentVersion)} => ${chalk_1.default.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'major';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    { name: `Visit ${chalk_1.default.bold('http://blog.ionic.io')} and ${chalk_1.default.bold('https://github.com/ionic-team/ionic/releases')} for upgrade instructions` },
                ];
            });
        }
    }
    Ailments.IonicAngularMajorUpdateAvailable = IonicAngularMajorUpdateAvailable;
    class AppScriptsUpdateAvailable extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'app-scripts-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getAppScriptsVersion(env, env.project);
                    this.latestVersion = yield npm_2.pkgLatestVersion(env, '@ionic/app-scripts');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Update available for ${chalk_1.default.bold('@ionic/app-scripts')}.\n` +
                    `An update is available for ${chalk_1.default.bold('@ionic/app-scripts')} (${chalk_1.default.cyan(currentVersion)} => ${chalk_1.default.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'minor' || diff === 'patch';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [, latestVersion] = yield this.getVersionPair(env);
                const [manager, ...managerArgs] = yield npm_2.pkgManagerArgs(env, { pkg: `@ionic/app-scripts@${latestVersion ? latestVersion : 'latest'}`, saveDev: true });
                return [
                    {
                        name: `Run: ${chalk_1.default.green(manager + ' ' + managerArgs.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.shell.run(manager, managerArgs, {});
                        }),
                    },
                ];
            });
        }
    }
    Ailments.AppScriptsUpdateAvailable = AppScriptsUpdateAvailable;
    class AppScriptsMajorUpdateAvailable extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'app-scripts-major-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getAppScriptsVersion(env, env.project);
                    this.latestVersion = yield npm_2.pkgLatestVersion(env, '@ionic/app-scripts');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Major update available for ${chalk_1.default.bold('@ionic/app-scripts')}.\n` +
                    `A major update is available for ${chalk_1.default.bold('@ionic/app-scripts')} (${chalk_1.default.cyan(currentVersion)} => ${chalk_1.default.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'major';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    { name: `Visit ${chalk_1.default.bold('https://github.com/ionic-team/ionic-app-scripts/releases')} for upgrade instructions` },
                ];
            });
        }
    }
    Ailments.AppScriptsMajorUpdateAvailable = AppScriptsMajorUpdateAvailable;
    class IonicNativeUpdateAvailable extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-native-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    try {
                        this.currentVersion = (yield npm_1.readPackageJsonFile(path.resolve(env.project.directory, 'node_modules', '@ionic-native', 'core', 'package.json'))).version;
                    }
                    catch (e) {
                        // Not installed
                    }
                    this.latestVersion = yield npm_2.pkgLatestVersion(env, '@ionic-native/core');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Update available for Ionic Native.\n` +
                    `An update is available for Ionic Native (${chalk_1.default.cyan(currentVersion)} => ${chalk_1.default.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'minor' || diff === 'patch';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [, latestVersion] = yield this.getVersionPair(env);
                const modules = yield fs_1.fsReadDir(path.resolve(env.project.directory, 'node_modules', '@ionic-native'));
                return yield Promise.all(modules.filter(m => m).map((m) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const [manager, ...managerArgs] = yield npm_2.pkgManagerArgs(env, { pkg: `@ionic-native/${m}@${latestVersion ? latestVersion : 'latest'}` });
                    return {
                        name: `Run: ${chalk_1.default.green(manager + ' ' + managerArgs.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.shell.run(manager, managerArgs, {});
                        }),
                    };
                })));
            });
        }
    }
    Ailments.IonicNativeUpdateAvailable = IonicNativeUpdateAvailable;
    class IonicNativeMajorUpdateAvailable extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-native-major-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    try {
                        this.currentVersion = (yield npm_1.readPackageJsonFile(path.resolve(env.project.directory, 'node_modules', '@ionic-native', 'core', 'package.json'))).version;
                    }
                    catch (e) {
                        // Not installed
                    }
                    this.latestVersion = yield npm_2.pkgLatestVersion(env, '@ionic-native/core');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Major update available for Ionic Native.\n` +
                    `A major update is available for Ionic Native (${chalk_1.default.cyan(currentVersion)} => ${chalk_1.default.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'major';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [, latestVersion] = yield this.getVersionPair(env);
                const args = yield npm_2.pkgManagerArgs(env, { pkg: `@ionic-native/core@${latestVersion ? latestVersion : 'latest'}` });
                return [
                    { name: `Visit ${chalk_1.default.bold('https://github.com/ionic-team/ionic-native/releases')}, looking for breaking changes` },
                    { name: `Update each ${chalk_1.default.bold('@ionic-native/')} package. For example, ${chalk_1.default.green(args.join(' '))}` },
                    { name: `Update your app according to the breaking changes, if any` },
                ];
            });
        }
    }
    Ailments.IonicNativeMajorUpdateAvailable = IonicNativeMajorUpdateAvailable;
    class IonicNativeOldVersionInstalled extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-native-old-version-installed';
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Old version of Ionic Native installed.\n` +
                    `Ionic Native ${chalk_1.default.bold('ionic-native')} has been restructured into individual packages under the ${chalk_1.default.bold('@ionic-native/')} namespace to allow for better bundling and faster apps.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return fs_1.pathExists(path.join(env.project.directory, 'node_modules', 'ionic-native'));
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const args = yield npm_2.pkgManagerArgs(env, { pkg: 'ionic-native', command: 'uninstall' });
                return [
                    { name: `Run ${chalk_1.default.green(args.join(' '))}` },
                    { name: `Refer to ${chalk_1.default.bold('https://ionicframework.com/docs/native')} for installation & usage instructions` },
                ];
            });
        }
    }
    Ailments.IonicNativeOldVersionInstalled = IonicNativeOldVersionInstalled;
    class UnsavedCordovaPlatforms extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'unsaved-cordova-platforms';
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Cordova platforms unsaved.\n` +
                    `There are Cordova platforms installed that are not saved in ${chalk_1.default.bold('config.xml')} or ${chalk_1.default.bold('package.json')}. It is good practice to manage Cordova platforms and their versions. See ${chalk_1.default.bold('https://cordova.apache.org/docs/en/latest/platform_plugin_versioning_ref/')} for more information.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                // const packageJson = await env.project.loadPackageJson();
                if (!project.integrations.cordova) {
                    return false;
                }
                // if (!isCordovaPackageJson(packageJson)) {
                //   return false;
                // }
                const platforms = yield project_1.getPlatforms(env.project.directory);
                const conf = yield config_1.ConfigXml.load(env.project.directory);
                const engines = conf.getPlatformEngines();
                const engineNames = new Set([...engines.map(e => e.name)]);
                // const packageJsonPlatforms = new Set([...packageJson.cordova.platforms]);
                const configXmlDiff = platforms.filter(p => !engineNames.has(p));
                // const packageJsonDiff = platforms.filter(p => !packageJsonPlatforms.has(p));
                // return configXmlDiff.length > 0 || packageJsonDiff.length > 0;
                return configXmlDiff.length > 0;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const args = ['cordova', 'platform', 'save'];
                return [
                    {
                        name: `Run: ${chalk_1.default.green('ionic ' + args.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.runCommand(args);
                        }),
                    },
                ];
            });
        }
    }
    Ailments.UnsavedCordovaPlatforms = UnsavedCordovaPlatforms;
    class DefaultCordovaBundleIdUsed extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'default-cordova-bundle-id-used';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Bundle ID unchanged in ${chalk_1.default.bold('config.xml')}.\n` +
                    `The "bundle identifier" is a unique ID (usually written in reverse DNS notation, such as ${chalk_1.default.bold('com.mycompany.MyApp')}) that Cordova uses when compiling the native build of your app. When your app is submitted to the App Store or Play Store, the bundle ID can't be changed. This issue was detected because this app's bundle ID is ${chalk_1.default.green('"io.ionic.starter"')}, which is the default bundle ID provided after running ${chalk_1.default.green('ionic start')}.`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const conf = yield config_1.ConfigXml.load(env.project.directory);
                if (!project.integrations.cordova) {
                    return false;
                }
                return conf.getBundleId() === 'io.ionic.starter';
            });
        }
        getTreatmentSteps() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    { name: `Change the ${chalk_1.default.bold('id')} attribute of ${chalk_1.default.bold('<widget>')} (root element) to something other than ${chalk_1.default.green('"io.ionic.starter"')}` },
                ];
            });
        }
    }
    Ailments.DefaultCordovaBundleIdUsed = DefaultCordovaBundleIdUsed;
    class ViewportFitNotSet extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'viewport-fit-not-set';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`${chalk_1.default.bold('viewport-fit=cover')} not set in ${chalk_1.default.bold('index.html')}\n` +
                    `iOS 11 introduces new "safe regions" for webviews, which can throw off component sizing, squish the header into the status bar, letterbox the app on iPhone X, etc. Fixing this issue will ensure the webview takes up the full size of the screen. See ${chalk_1.default.bold('https://blog.ionic.io/ios-11-checklist')} for more information.`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const indexHtml = yield fs_1.fsReadFile(path.resolve(yield env.project.getSourceDir(), 'index.html'), { encoding: 'utf8' });
                const m = indexHtml.match(/\<meta.*viewport-fit=cover/);
                return !Boolean(m);
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    { name: `Add ${chalk_1.default.bold('viewport-fit=cover')} to the ${chalk_1.default.bold('<meta name="viewport">')} tag in your ${chalk_1.default.bold('index.html')} file` },
                ];
            });
        }
    }
    Ailments.ViewportFitNotSet = ViewportFitNotSet;
    class CordovaPlatformsCommitted extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'cordova-platforms-committed';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Cordova ${chalk_1.default.bold('platforms/')} directory is committed to git.\n` +
                    `Cordova considers ${chalk_1.default.bold('platforms/')} and ${chalk_1.default.bold('plugins/')} build artifacts${chalk_1.default.cyan('[1]')}, and routinely overwrites files.\n\n` +
                    `While committing these files might be necessary for some projects${chalk_1.default.cyan('[2]')}, generally platforms should be configured using ${chalk_1.default.bold('config.xml')} and Cordova hooks${chalk_1.default.cyan('[3]')} so that your project is more portable and SDK updates are easier.\n\n` +
                    `${chalk_1.default.cyan('[1]')}: ${chalk_1.default.bold('https://cordova.apache.org/docs/en/latest/reference/cordova-cli/#version-control')}\n` +
                    `${chalk_1.default.cyan('[2]')}: ${chalk_1.default.bold('https://cordova.apache.org/docs/en/latest/reference/cordova-cli/#platforms')}\n` +
                    `${chalk_1.default.cyan('[3]')}: ${chalk_1.default.bold('https://cordova.apache.org/docs/en/latest/guide/appdev/hooks/index.html')}\n` +
                    `\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!(yield git_1.isRepoInitialized(env))) {
                    return false;
                }
                const cmdInstalled = yield env.shell.cmdinfo('git', ['--version']);
                if (!cmdInstalled) {
                    return false;
                }
                const files = (yield env.shell.run('git', ['ls-tree', '--name-only', 'HEAD'], { showCommand: false })).split('\n');
                return files.includes('platforms'); // TODO
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [];
            });
        }
    }
    Ailments.CordovaPlatformsCommitted = CordovaPlatformsCommitted;
    Ailments.ALL = [
        AutomaticUpdatesOff,
        NpmInstalledLocally,
        IonicCLIInstalledLocally,
        GitNotUsed,
        GitConfigInvalid,
        IonicAngularUpdateAvailable,
        IonicAngularMajorUpdateAvailable,
        AppScriptsUpdateAvailable,
        AppScriptsMajorUpdateAvailable,
        IonicNativeOldVersionInstalled,
        IonicNativeUpdateAvailable,
        IonicNativeMajorUpdateAvailable,
        UnsavedCordovaPlatforms,
        CordovaPlatformsCommitted,
        DefaultCordovaBundleIdUsed,
        ViewportFitNotSet,
    ];
})(Ailments = exports.Ailments || (exports.Ailments = {}));
