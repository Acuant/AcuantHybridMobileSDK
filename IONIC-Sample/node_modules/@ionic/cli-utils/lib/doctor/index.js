"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const guards_1 = require("../../guards");
const ailments_1 = require("./ailments");
const ERROR_AILMENT_SKIPPED = 'AILMENT_SKIPPED';
const ERROR_AILMENT_IGNORED = 'AILMENT_IGNORED';
class AilmentRegistry {
    constructor() {
        this._ailments = [];
    }
    register(ailment) {
        this._ailments.push(ailment);
    }
    get ailments() {
        return this._ailments;
    }
    get(id) {
        return this._ailments.find(a => a.id === id);
    }
}
exports.AilmentRegistry = AilmentRegistry;
exports.registry = new AilmentRegistry();
for (let Ailment of ailments_1.Ailments.ALL) {
    exports.registry.register(new Ailment());
}
function treatAilments(env) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = yield env.config.load();
        let count = 0;
        const isLoggedIn = yield env.session.isLoggedIn();
        if (!isLoggedIn) {
            env.log.warn(`For best results, please make sure you're logged in to Ionic.\nSome issues can't be detected without authentication. Run:\n\n    ${chalk_1.default.green('ionic login')}`);
        }
        env.tasks.next('Detecting issues');
        const ailments = yield Promise.all(exports.registry.ailments.map((ailment) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (ailment.requiresAuthentication && !isLoggedIn) {
                return [ailment, false];
            }
            const detected = yield ailment.detected(env);
            count++;
            env.tasks.updateMsg(`Detecting issues: ${chalk_1.default.bold(`${count} / ${exports.registry.ailments.length}`)} complete`);
            return [ailment, detected];
        })));
        env.tasks.updateMsg(`Detecting issues: ${chalk_1.default.bold(`${exports.registry.ailments.length} / ${exports.registry.ailments.length}`)} complete`);
        const detectedAilments = ailments
            .filter(([, detected]) => detected)
            .map(([ailment,]) => ailment)
            .filter(ailment => !config.state.doctor.ignored.includes(ailment.id));
        let treatedAilmentCount = 0;
        let manuallyTreatableAilmentCount = 0;
        env.tasks.end();
        const fn = detectedAilments.length > 0 ? env.log.info.bind(env.log) : env.log.ok.bind(env.log);
        fn(`Detected ${chalk_1.default.bold(String(detectedAilments.length))} issue${detectedAilments.length === 1 ? '' : 's'}.${detectedAilments.length === 0 ? ' Aww yeah! ðŸ’ª' : ''}`);
        if (detectedAilments.length > 0) {
            for (let ailment of detectedAilments) {
                const treated = yield treatAilment(env, ailment);
                if (ailment instanceof ailments_1.AutomaticallyTreatableAilment) {
                    if (treated) {
                        treatedAilmentCount++;
                    }
                }
                else {
                    manuallyTreatableAilmentCount++;
                }
            }
            if (treatedAilmentCount > 0) {
                const fn = manuallyTreatableAilmentCount > 0 ? env.log.info.bind(env.log) : env.log.ok.bind(env.log);
                fn(`Fixed ${treatedAilmentCount} issue${treatedAilmentCount === 1 ? '' : 's'}!`);
            }
            if (manuallyTreatableAilmentCount > 0) {
                env.log.info(`${manuallyTreatableAilmentCount} ${manuallyTreatableAilmentCount === 1 ? 'issue needs' : 'issues need'} to be fixed manually.`);
            }
        }
    });
}
exports.treatAilments = treatAilments;
function detectAndTreatAilment(env, ailment) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const detected = yield ailment.detected(env);
        if (detected) {
            yield treatAilment(env, ailment);
        }
        else {
            env.log.ok(`All good! ${chalk_1.default.green(ailment.id)} not detected.`);
        }
    });
}
exports.detectAndTreatAilment = detectAndTreatAilment;
function treatAilment(env, ailment) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (ailment instanceof ailments_1.AutomaticallyTreatableAilment) {
            try {
                const treated = yield automaticallyTreatAilment(env, ailment);
                return treated;
            }
            catch (e) {
                if (e !== ERROR_AILMENT_SKIPPED && e !== ERROR_AILMENT_IGNORED) {
                    if (guards_1.isExitCodeException(e)) {
                        env.log.error(`Error occurred during automatic fix: ${e.message}`);
                    }
                    else {
                        env.log.error(`Error occurred during automatic fix: ${e.stack ? e.stack : e}`);
                    }
                }
            }
        }
        else {
            const treatmentSteps = yield ailment.getTreatmentSteps(env);
            const stepOutput = treatmentSteps.length > 0 ? `To fix, take the following step(s):\n\n${treatmentSteps.map((step, i) => `    ${i + 1}) ${step.name}`).join('\n')}` : '';
            env.log.warn(`${yield ailment.getMessage(env)} ${stepOutput}\n\n` +
                `Ignore this issue with: ${chalk_1.default.green(`ionic doctor ignore ${ailment.id}`)}`);
        }
        return false;
    });
}
function automaticallyTreatAilment(env, ailment) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = yield env.config.load();
        const treatmentSteps = yield ailment.getTreatmentSteps(env);
        const stepOutput = treatmentSteps.map((step, i) => `    ${i + 1}) ${step.name}`).join('\n');
        env.log.warn(`${yield ailment.getMessage(env)} To fix, the following step(s) need to be taken:\n\n${stepOutput}`);
        const CHOICE_YES = 'yes';
        const CHOICE_NO = 'no';
        const CHOICE_IGNORE = 'ignore';
        const choice = yield env.prompt({
            type: 'list',
            name: 'choice',
            message: `Fix automatically?`,
            choices: [
                {
                    name: 'Yes',
                    value: CHOICE_YES,
                },
                {
                    name: 'No',
                    value: CHOICE_NO,
                },
                {
                    name: 'Ignore forever',
                    value: CHOICE_IGNORE,
                },
            ],
        });
        if (choice === CHOICE_YES) {
            // env.tasks.next(`Steps`);
            for (let i in treatmentSteps) {
                const step = treatmentSteps[i];
                env.log.debug(typeof i);
                // env.tasks.updateMsg(`Steps: ${chalk.bold(`${Number(i) + 1} / ${treatmentSteps.length}`)}`);
                try {
                    yield step.treat();
                }
                catch (e) {
                    if (!guards_1.isExitCodeException(e) || e.exitCode > 0) {
                        throw e;
                    }
                }
            }
            // env.tasks.updateMsg(`Steps: ${chalk.bold(`${treatmentSteps.length} / ${treatmentSteps.length}`)}`);
            // env.tasks.end();
            return true;
        }
        else if (choice === CHOICE_NO) {
            throw ERROR_AILMENT_SKIPPED;
        }
        else if (choice === CHOICE_IGNORE) {
            config.state.doctor.ignored.push(ailment.id);
            throw ERROR_AILMENT_IGNORED;
        }
        return false;
    });
}
