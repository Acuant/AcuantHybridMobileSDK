"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = require("chalk");
const errors_1 = require("./errors");
exports.DEFAULT_DEV_LOGGER_PORT = 53703;
exports.DEFAULT_LIVERELOAD_PORT = 35729;
exports.DEFAULT_SERVER_PORT = 8100;
exports.IONIC_LAB_URL = '/ionic-lab';
exports.BIND_ALL_ADDRESS = '0.0.0.0';
exports.LOCAL_ADDRESSES = ['localhost', '127.0.0.1'];
exports.BROWSERS = ['safari', 'firefox', process.platform === 'win32' ? 'chrome' : (process.platform === 'darwin' ? 'google chrome' : 'google-chrome')];
function selectExternalIP(env, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { getSuitableNetworkInterfaces } = yield Promise.resolve().then(function () { return require('./utils/network'); });
        let availableInterfaces = [];
        let chosenIP = options.address;
        if (options.address === exports.BIND_ALL_ADDRESS) {
            availableInterfaces = getSuitableNetworkInterfaces();
            if (availableInterfaces.length === 0) {
                if (options.externalAddressRequired) {
                    throw new errors_1.FatalException(`No external network interfaces detected. In order to use livereload with run/emulate you will need one.\n` +
                        `Are you connected to a local network?\n`);
                }
            }
            else if (availableInterfaces.length === 1) {
                chosenIP = availableInterfaces[0].address;
            }
            else if (availableInterfaces.length > 1) {
                if (options.externalAddressRequired) {
                    env.log.warn('Multiple network interfaces detected!\n' +
                        'You will be prompted to select an external-facing IP for the livereload server that your device or emulator has access to.\n\n' +
                        `You may also use the ${chalk_1.default.green('--address')} option to skip this prompt.`);
                    const promptedIp = yield env.prompt({
                        type: 'list',
                        name: 'promptedIp',
                        message: 'Please select which IP to use:',
                        choices: availableInterfaces.map(i => ({
                            name: `${i.address} ${chalk_1.default.dim(`(${i.deviceName})`)}`,
                            value: i.address,
                        })),
                    });
                    chosenIP = promptedIp;
                }
            }
        }
        return [chosenIP, availableInterfaces];
    });
}
exports.selectExternalIP = selectExternalIP;
function gatherDevAppDetails(env, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let devAppActive = !options.iscordovaserve && options.devapp;
        if (devAppActive) {
            const { getSuitableNetworkInterfaces } = yield Promise.resolve().then(function () { return require('./utils/network'); });
            const { computeBroadcastAddress } = yield Promise.resolve().then(function () { return require('./devapp'); });
            const availableInterfaces = getSuitableNetworkInterfaces();
            // TODO: Unfortunately, we can't do this yet--there is no
            // accurate/reliable/realistic way to identify a WiFi network uniquely in
            // NodeJS. The best thing we can do is tell the dev what is happening.
            // const config = await env.config.load();
            // const knownInterfaces = new Set(config.devapp.knownInterfaces.map(i => i.mac));
            // const diff = [...new Set(availableInterfaces.filter(i => !knownInterfaces.has(i.mac)))];
            // if (diff.length > 0) {
            //   env.log.warn(
            //     `New network interface(s) detected!\n` +
            //     `You will be prompted to select which network interfaces are trusted for your app to show up in Ionic DevApp. If you're on public WiFi, you may not want to broadcast your app. To trust all networks, just press ${chalk.cyan.bold('<enter>')}.\n\n` +
            //     `Need to install the DevApp? ${emoji('ðŸ‘‰ ', '-->')} ${chalk.bold('https://bit.ly/ionic-dev-app')}`
            //   );
            //   const trustedInterfaceMacs = await env.prompt({
            //     type: 'checkbox',
            //     name: 'checkbox',
            //     message: 'Please select trusted interfaces:',
            //     choices: diff.map(i => ({
            //       name: `${chalk.bold(i.address)} ${chalk.dim(`(mac: ${i.mac}, label: ${i.deviceName})`)}`,
            //       value: i.mac,
            //       checked: true,
            //     })),
            //   });
            //   const untrustedInterfaceMacs = diff
            //     .filter(i => !trustedInterfaceMacs.includes(i.mac))
            //     .map(i => i.mac);
            //   const trustedInterfaces = trustedInterfaceMacs.map(mac => ({ trusted: true, mac }));
            //   const untrustedInterfaces = untrustedInterfaceMacs.map(mac => ({ trusted: false, mac }));
            //   config.devapp.knownInterfaces = config.devapp.knownInterfaces.concat(trustedInterfaces);
            //   config.devapp.knownInterfaces = config.devapp.knownInterfaces.concat(untrustedInterfaces);
            // }
            // const trustedInterfaceMacs = config.devapp.knownInterfaces
            //   .filter(i => i.trusted)
            //   .map(i => i.mac);
            // const availableTrustedInterfaces = availableInterfaces.filter(i => trustedInterfaceMacs.includes(i.mac));
            const interfaces = availableInterfaces
                .map(i => (Object.assign({}, i, { broadcast: computeBroadcastAddress(i.address, i.netmask) })));
            return { interfaces };
        }
    });
}
exports.gatherDevAppDetails = gatherDevAppDetails;
function publishDevApp(env, options, details) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let devAppActive = !options.iscordovaserve && options.devapp;
        if (devAppActive) {
            const { createPublisher } = yield Promise.resolve().then(function () { return require('./devapp'); });
            const publisher = yield createPublisher(env, details.port);
            publisher.interfaces = details.interfaces;
            publisher.on('error', (err) => {
                env.log.debug(`Error in DevApp service: ${String(err.stack ? err.stack : err)}`);
            });
            try {
                yield publisher.start();
            }
            catch (e) {
                env.log.error(`Could not publish DevApp service: ${String(e.stack ? e.stack : e)}`);
            }
            return publisher.name;
        }
    });
}
exports.publishDevApp = publishDevApp;
